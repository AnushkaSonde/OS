#include <stdio.h>

struct Process {
    int pid, at, bt, priority;
    int ct, tat, wt, remaining;
};

// Function to calculate TAT & WT
void calculateTimes(struct Process p[], int n) {
    for(int i=0;i<n;i++) {
        p[i].tat = p[i].ct - p[i].at;
        p[i].wt = p[i].tat - p[i].bt;
    }
}

// Display table
void display(struct Process p[], int n, char algo[]) {
    printf("\n==== %s ====\n", algo);
    printf("PID\tAT\tBT\tPri\tCT\tTAT\tWT\n");
    for(int i=0;i<n;i++)
        printf("P%d\t%d\t%d\t%d\t%d\t%d\t%d\n",
            p[i].pid, p[i].at, p[i].bt, p[i].priority,
            p[i].ct, p[i].tat, p[i].wt);
}


// FCFS Scheduling
void fcfs(struct Process p[], int n) {
    int time = 0;
    for(int i=0;i<n;i++) {
        if(time < p[i].at)
            time = p[i].at; // CPU idle

        time += p[i].bt;
        p[i].ct = time;
    }
    calculateTimes(p, n);
    display(p, n, "FCFS");
}


// SJF Non-Preemptive
void sjf_non_preemptive(struct Process p[], int n) {
    int time = 0, completed = 0, i;
    int done[n];
    for(i=0; i<n; i++) done[i] = 0;

    while(completed < n) {
        int idx = -1;
        int min = 999;

        for(i=0;i<n;i++) {
            if(!done[i] && p[i].at <= time && p[i].bt < min) {
                min = p[i].bt;
                idx = i;
            }
        }

        if(idx == -1) { time++; continue; }

        time += p[idx].bt;
        p[idx].ct = time;
        done[idx] = 1;
        completed++;
    }

    calculateTimes(p,n);
    display(p,n,"SJF Non-Preemptive");
}


// SJF Preemptive (SRTF)
void sjf_preemptive(struct Process p[], int n) {
    int time = 0, completed = 0, i;
    for(i=0;i<n;i++) p[i].remaining = p[i].bt;

    while(completed < n) {
        int idx = -1, min = 999;

        for(i=0;i<n;i++)
            if(p[i].at <= time && p[i].remaining > 0 && p[i].remaining < min) {
                min = p[i].remaining;
                idx = i;
            }

        if(idx == -1) { time++; continue; }

        p[idx].remaining--;
        time++;

        if(p[idx].remaining == 0) {
            p[idx].ct = time;
            completed++;
        }
    }

    calculateTimes(p,n);
    display(p,n,"SJF Preemptive");
}


// Priority Non-Preemptive
void priority_non_preemptive(struct Process p[], int n) {
    int time = 0, completed = 0, i;
    int done[n];
    for(i=0;i<n;i++) done[i] = 0;

    while(completed < n) {
        int idx = -1, min = 999;

        for(i=0;i<n;i++)
            if(!done[i] && p[i].at <= time && p[i].priority < min) {
                min = p[i].priority;
                idx = i;
            }

        if(idx == -1) { time++; continue; }

        time += p[idx].bt;
        p[idx].ct = time;
        done[idx] = 1;
        completed++;
    }

    calculateTimes(p,n);
    display(p,n,"Priority Non-Preemptive");
}


// Priority Preemptive
void priority_preemptive(struct Process p[], int n) {
    int time = 0, completed = 0, i;
    for(i=0;i<n;i++) p[i].remaining = p[i].bt;

    while(completed < n) {
        int idx = -1, min = 999;

        for(i=0;i<n;i++)
            if(p[i].at <= time && p[i].remaining > 0 && p[i].priority < min) {
                min = p[i].priority;
                idx = i;
            }

        if(idx == -1) { time++; continue; }

        p[idx].remaining--;
        time++;

        if(p[idx].remaining == 0) {
            p[idx].ct = time;
            completed++;
        }
    }

    calculateTimes(p,n);
    display(p,n,"Priority Preemptive");
}


// Round Robin
void round_robin(struct Process p[], int n, int quantum) {
    int time = 0, completed = 0, i;

    for(i=0;i<n;i++) p[i].remaining = p[i].bt;

    while(completed < n) {
        for(i=0;i<n;i++) {
            if(p[i].remaining > 0 && p[i].at <= time) {
                int exec = (p[i].remaining >= quantum) ? quantum : p[i].remaining;
                p[i].remaining -= exec;
                time += exec;

                if(p[i].remaining == 0) {
                    p[i].ct = time;
                    completed++;
                }
            }
        }
    }

    calculateTimes(p,n);
    display(p,n,"Round Robin");
}


// MAIN FUNCTION
int main() {
    int n = 4;
    struct Process p[4] = {
        {1,0,7,2},
        {2,2,4,1},
        {3,4,1,3},
        {4,5,4,4}
    };

    fcfs(p,n);
    sjf_non_preemptive(p,n);
    sjf_preemptive(p,n);
    priority_non_preemptive(p,n);
    priority_preemptive(p,n);
    round_robin(p,n,2);

    return 0;
}

